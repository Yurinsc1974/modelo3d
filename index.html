<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard 3D - Barragem (Dinâmico do Excel)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b1020; color: #e6e8ef; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #app { position: fixed; inset: 0; display: grid; grid-template-columns: 1fr; grid-template-rows: 1fr; }
    #scene { grid-area: 1 / 1; }
    #ui { grid-area: 1 / 1; pointer-events: none; }

    .panel { position: absolute; top: 16px; left: 16px; background: rgba(10,15,35,.75); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 12px 14px; backdrop-filter: blur(6px); pointer-events: auto; display: flex; gap: 10px; align-items: center; }
    label { font-size: 12px; color: #c9d1e1; margin-right: 6px; }
    select { background: #11162b; border: 1px solid #2a355a; color: #e6e8ef; border-radius: 8px; padding: 6px 8px; }
    button { background: #2a355a; color: #fff; border: none; border-radius: 8px; padding: 8px 10px; cursor: pointer; }
    button:hover { background: #3b4980; }

    .logo { position: absolute; top: 12px; right: 12px; height: 42px; pointer-events: auto; background: rgba(10,15,35,.15); border-radius: 8px; padding: 6px 8px; border: 1px solid rgba(255,255,255,.08); }

    .legend { position: absolute; bottom: 16px; left: 16px; background: rgba(10,15,35,.75); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 8px 12px; pointer-events: auto; }
    .legend .bar { width: 200px; height: 10px; background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71); border-radius: 6px; margin-top: 6px; }

    .tooltip { position: absolute; padding: 8px 10px; background: rgba(0,0,0,.85); color: #fff; font-size: 12px; border-radius: 8px; transform: translate(-50%, -120%); pointer-events: none; opacity: 0; transition: opacity .15s; max-width: 360px; }
    .tooltip table { border-collapse: collapse; width: 100%; font-size: 12px; }
    .tooltip td { padding: 2px 0; vertical-align: top; }
    .tooltip td:first-child { color: #aab4cf; padding-right: 8px; }

    .credit { position: absolute; right: 12px; bottom: 12px; color: #8b93a7; font-size: 12px; }

    .sidebar { position: absolute; top: 76px; left: 16px; width: 280px; display: grid; gap: 12px; pointer-events: auto; }
    .kpi { background: linear-gradient(180deg, rgba(31,41,77,.85), rgba(20,27,52,.85)); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .kpi h4 { margin: 0 0 8px 0; font-size: 12px; font-weight: 600; letter-spacing: .6px; color: #aab4cf; text-transform: uppercase; }
    .kpi .val { font-size: 28px; font-weight: 700; }
    .kpi .sub { font-size: 12px; color: #aab4cf; }

    .error { position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: #3b1b1b; color: #ffd5d5; border: 1px solid #b14a4a; padding: 10px 12px; border-radius: 10px; pointer-events: auto; max-width: 560px; }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="scene"></canvas>
    <div id="ui">
      <div class="panel">
        <div>
          <label for="dateSelect">Data:</label>
          <select id="dateSelect"><option value="Todos">Todos</option></select>
        </div>
        <div>
          <label for="areaSelect">Área:</label>
          <select id="areaSelect"><option value="Todos">Todos</option></select>
        </div>
        <button id="btnFullscreen" title="Entrar em tela cheia">Tela cheia</button>
      </div>

      <img class="logo" src="https://upload.wikimedia.org/wikipedia/pt/thumb/c/cc/Logotipo_Vale.svg/1920px-Logotipo_Vale.svg.png" alt="Logo"/>

      <div class="sidebar">
        <div class="kpi">
          <h4>Desempenho médio</h4>
          <div class="val" id="kpiRatio">n/d</div>
          <div class="sub">Média de Real / Planejado</div>
        </div>
        <div class="kpi">
          <h4>Real médio</h4>
          <div class="val" id="kpiReal">n/d</div>
          <div class="sub">Média (%) das áreas filtradas</div>
        </div>
        <div class="kpi">
          <h4>Planejado médio</h4>
          <div class="val" id="kpiPlan">n/d</div>
          <div class="sub">Média (%) das áreas filtradas</div>
        </div>
      </div>

      <div class="legend">
        <div>Cor do ponto = Desempenho (Real / Planejado)</div>
        <div class="bar"></div>
      </div>
      <div class="tooltip" id="tooltip"></div>
      <div class="credit">Fazendo 3D (Three.js)</div>
      <div class="error" id="error" style="display:none"></div>
    </div>
  </div>

  <script type="module">
    // ---------- CDNs (fallback) ----------
    async function loadThree() {
      const threeURLs = [
        'https://esm.sh/three@0.160.0',
        'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
        'https://unpkg.com/three@0.160.0/build/three.module.js'
      ];
      const controlsURLs = [
        'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js',
        'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js?module',
        'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module'
      ];
      let lastErr;
      for (let i=0;i<threeURLs.length;i++){
        try { const THREE = await import(threeURLs[i]); const mod = await import(controlsURLs[i]); return { THREE, OrbitControls: mod.OrbitControls }; } catch(e){ lastErr=e; console.warn('CDN falhou', i+1, e); }
      }
      throw lastErr;
    }
    async function loadSheetJS() {
      const urls = [
        'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
        'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js'
      ];
      for (const u of urls) {
        try { await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=u; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); if (window.XLSX) return window.XLSX; } catch(e){ console.warn('Falha SheetJS', u); }
      }
      throw new Error('Não foi possível carregar a biblioteca de Excel (SheetJS).');
    }

    // ---------- Helpers ----------
    const REQUIRED_AREAS = ['Dique','Maciço Principal','Miguel Congo','Regreide','Talude 08'];
    const PRESET_COORDS = {
      'Dique': [-20, 0, 0, 5],
      'Maciço Principal': [0, 0, 0, 8],
      'Miguel Congo': [20, 0, -10, 6],
      'Regreide': [-10, 0, 10, 4],
      'Talude 08': [10, 0, 12, 6],
    };
    const errBox = document.getElementById('error');
    function showError(msg){ errBox.style.display='block'; errBox.innerHTML = msg; }
    const norm = s => (s==null? '': String(s)).normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().trim();

    async function tryFetchExcel() {
      const candidates = ['./Base.xlsx','./Base 1.xlsx','./Base1.xlsx','./base.xlsx'];
      let lastErr; for (const url of candidates){ try { const r = await fetch(url, {cache:'no-store'}); if (r.ok) return await r.arrayBuffer(); lastErr = r.status+':'+url; } catch(e){ lastErr=e; } }
      throw new Error('Não foi possível baixar a planilha. Coloque <b>Base.xlsx</b> (ou "Base 1.xlsx") na raiz do repositório.');
    }

    function parsePercentNumber(v){
      if (v==null) return null;
      if (typeof v === 'number') return v; // 0.85 (85%) ou 85
      const s = String(v).trim().replace(',', '.');
      if (s.endsWith('%')) { const n = parseFloat(s.slice(0,-1)); return isNaN(n)? null : (n/100); }
      const n = parseFloat(s); return isNaN(n)? null : n; // "0.85" => 0.85
    }
    function fmtPct(n, digits=1){ return (n==null||!isFinite(n))? 'n/d' : (n*100).toFixed(digits).replace('.',',') + '%'; }

    function excelSerialToDate(n){ const base = new Date(Date.UTC(1899,11,30)); return new Date(base.getTime() + (Number(n)||0)*86400000); }
    function parseDateFlexible(v){ if (v==null) return null; if (typeof v==='number') return excelSerialToDate(v); const s=String(v).trim(); const d1=new Date(s); if(!isNaN(d1)) return d1; const m=s.match(/^(\d{4})-(\d{2})-(\d{2})/); if(m) return new Date(`${m[1]}-${m[2]}-${m[3]}T00:00:00Z`); const n=parseFloat(s); if(!isNaN(n)) return excelSerialToDate(n); return null; }

    function objEntriesOrdered(o){ return Object.keys(o).map(k=>[k,o[k]]); }

    const { THREE, OrbitControls } = await loadThree();
    const XLSX = await loadSheetJS();

    // ---------- THREE ----------
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({canvas, antialias: true}); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0b1020);
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000); camera.position.set(45,30,45);
    const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.target.set(0,4,0);
    scene.add(new THREE.HemisphereLight(0xbfd7ff, 0x0b142a, 1.2)); const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(30,50,10); dir.castShadow=true; scene.add(dir);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1a203a, roughness:0.95})); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
    const water = new THREE.Mesh(new THREE.PlaneGeometry(140,90), new THREE.MeshPhysicalMaterial({color:0x2c6fff, roughness:0.2, transmission:0.75, opacity:0.75, transparent:true})); water.rotation.x=-Math.PI/2; water.position.set(-10,0.05,-10); scene.add(water);
    const dam = new THREE.Group(); const damBody = new THREE.Mesh(new THREE.BoxGeometry(60,12,20), new THREE.MeshStandardMaterial({color:0x6b6f7a})); damBody.position.set(10,6,0); damBody.rotation.z=THREE.MathUtils.degToRad(-10); damBody.castShadow=true; damBody.receiveShadow=true; dam.add(damBody); const crest = new THREE.Mesh(new THREE.BoxGeometry(60,2,6), new THREE.MeshStandardMaterial({color:0x9aa0a6})); crest.position.set(10,12.5,0); dam.add(crest); scene.add(dam);

    const areaSelect = document.getElementById('areaSelect'); const dateSelect = document.getElementById('dateSelect'); const tooltip = document.getElementById('tooltip');
    const kpiRatio = document.getElementById('kpiRatio'); const kpiReal = document.getElementById('kpiReal'); const kpiPlan = document.getElementById('kpiPlan');

    const markers = new THREE.Group(); scene.add(markers);
    const sphereGeo = new THREE.SphereGeometry(1.2,32,16); // declarada UMA vez

    // --- FUNÇÃO DE COR (antes de buildMarkers) ---
    function colorFromRatio(r){
      if (r==null || !isFinite(r)) return new THREE.Color(0x95a5a6);
      const t = (Math.max(0.7, Math.min(1.3, r)) - 0.7) / 0.6; // 0.7->0, 1.3->1
      const c = new THREE.Color(); c.setHSL(0.0 + t*0.33, 0.85, 0.5);
      return c;
    }

    let ALL_ROWS = []; let HEADERS = [];
    try {
      const buf = await tryFetchExcel();
      const wb = XLSX.read(buf, {type:'array'}); const ws = wb.Sheets[wb.SheetNames[0]]; if (!ws) throw new Error('Planilha vazia.');
      const asMatrix = XLSX.utils.sheet_to_json(ws, {header:1, defval:null, raw:false});
      let headerIdx=-1, headerRow=null; for (let i=0;i<Math.min(asMatrix.length, 25); i++){ const r=asMatrix[i]||[]; const normalized=r.map(c=> norm(c)); const hasArea = normalized.some(c=> c.includes('area')); const coverage = normalized.filter(c=>c).length; if (hasArea && coverage>=2){ headerIdx=i; headerRow=r; break; } }
      if (headerIdx===-1) throw new Error('Cabeçalho não encontrado. A planilha deve conter uma coluna "Área".');
      HEADERS = headerRow.map(h=> String(h||'').trim());
      const data = XLSX.utils.sheet_to_json(ws, {header:HEADERS, range: headerIdx+1, defval:null, raw:false});
      const normToOrig={}; HEADERS.forEach(h=> normToOrig[norm(h)] = h);
      const keys = Object.keys(normToOrig);
      const areaKey = 'area' in normToOrig ? 'area' : (keys.find(k=>k.includes('area')) || null);
      const dateKey = 'data' in normToOrig ? 'data' : (keys.find(k=>k.includes('data')) || null);
      const realKey = ('real' in normToOrig) ? 'real' : (('real2' in normToOrig) ? 'real2' : (keys.find(k=>k.startsWith('real')) || null));
      const planKey = ('planejado' in normToOrig) ? 'planejado' : (('previsto' in normToOrig) ? 'previsto' : (keys.find(k=>k.includes('planejad') || k.includes('previst')) || null));
      const areaName = areaKey? normToOrig[areaKey] : null;
      const dateName = dateKey? normToOrig[dateKey] : null;
      const realName = realKey? normToOrig[realKey] : null;
      const planName = planKey? normToOrig[planKey] : null;
      if (!areaName) throw new Error('Coluna "Área" não encontrada.');
      ALL_ROWS = data.map(row=>({ area: row[areaName]? String(row[areaName]).trim():null, date: dateName? parseDateFlexible(row[dateName]) : null, real: realName? parsePercentNumber(row[realName]) : null, plan: planName? parsePercentNumber(row[planName]) : null, all: row })).filter(x=> x.area);
      for (const a of REQUIRED_AREAS){ if (!ALL_ROWS.some(x=> norm(x.area)===norm(a))) ALL_ROWS.push({area:a, date:null, real:null, plan:null, all:{'Área':a}}); }
    } catch(e){ console.error(e); showError(e.message + '<br><small>Dica: coloque <b>Base.xlsx</b> (ou "Base 1.xlsx") na raiz do repositório. A primeira aba deve conter uma linha de títulos com uma coluna "Área".</small>'); }

    function uniqueDates(){ const s=new Set(); for (const r of ALL_ROWS){ if (r.date){ s.add(r.date.toISOString().slice(0,10)); } } return Array.from(s).sort(); }
    function uniqueAreas(){ const s=new Set(REQUIRED_AREAS); for (const r of ALL_ROWS){ if (r.area) s.add(r.area);} return Array.from(s); }

    function buildSelectors(){ dateSelect.innerHTML='<option value="Todos">Todos</option>'+uniqueDates().map(d=>`<option value="${d}">${d}</option>`).join(''); areaSelect.innerHTML='<option value="Todos">Todos</option>'+uniqueAreas().map(a=>`<option value="${a}">${a}</option>`).join(''); }

    function aggregateForDate(selDate){ const byArea=new Map(); for(const r of ALL_ROWS){ const d=r.date; if(selDate!=='Todos' && d && d.toISOString().slice(0,10)!==selDate) continue; const prev=byArea.get(r.area); if(!prev) byArea.set(r.area, r); else { if(!prev.date && d) byArea.set(r.area, r); else if(prev.date && d && d>prev.date) byArea.set(r.area, r);} } for (const a of REQUIRED_AREAS){ if(!byArea.has(a)) byArea.set(a,{area:a,date:null,real:null,plan:null,all:{'Área':a}});} return Array.from(byArea.values()); }

    function updateKPI(rows){ const ratios=rows.map(r=> (r.real!=null&&r.plan)? (r.plan!==0? r.real/r.plan:null):null).filter(x=>x!=null&&isFinite(x)); const reals=rows.map(r=>r.real).filter(x=>x!=null&&isFinite(x)); const plans=rows.map(r=>r.plan).filter(x=>x!=null&&isFinite(x)); const mean=a=>a.length? a.reduce((p,c)=>p+c,0)/a.length:null; kpiRatio.textContent=fmtPct(mean(ratios)); kpiReal.textContent=fmtPct(mean(reals)); kpiPlan.textContent=fmtPct(mean(plans)); }

    const areaToObject = new Map();
    function buildMarkers(selDate='Todos', selArea='Todos'){ while(markers.children.length) markers.remove(markers.children[0]); areaToObject.clear(); const rows=aggregateForDate(selDate).filter(r=> selArea==='Todos'? true : r.area===selArea); for (const d of rows){ const coords=PRESET_COORDS[d.area] || [0,0,0,5]; const [x,y,z,h]=coords; const ratio=(d.real!=null&&d.plan)?(d.plan!==0? d.real/d.plan:null):null; const mat=new THREE.MeshStandardMaterial({color: colorFromRatio(ratio), roughness:0.4}); const mesh=new THREE.Mesh(sphereGeo, mat); mesh.position.set(x,h,z); mesh.castShadow=true; mesh.userData={...d, ratio, height:h}; const ped=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,h,12), new THREE.MeshStandardMaterial({color:0x3a466f, roughness:0.9})); ped.position.set(x,h/2,z); ped.castShadow=true; ped.receiveShadow=true; markers.add(ped); markers.add(mesh); areaToObject.set(d.area, mesh);} updateKPI(rows); }

    const raycaster=new THREE.Raycaster(); const mouse=new THREE.Vector2(); function onPointerMove(e){ const rect=renderer.domElement.getBoundingClientRect(); mouse.x=((e.clientX-rect.left)/rect.width)*2-1; mouse.y=-((e.clientY-rect.top)/rect.height)*2+1; raycaster.setFromCamera(mouse, camera); const it=raycaster.intersectObjects(markers.children,true).filter(i=> i.object.geometry===sphereGeo); if(it.length){ const d=it[0].object.userData; tooltip.style.left=e.clientX+'px'; tooltip.style.top=e.clientY+'px'; tooltip.style.opacity=1; tooltip.innerHTML=(function buildTooltip(){ const entries=objEntriesOrdered(d.all||{}); let rows=''; const important=new Set(['area','data','real','real2','planejado','previsto']); for (const [k,v] of entries){ if(k==null||String(k).trim()==='') continue; const nk=norm(k); let vv=v; if(important.has(nk)){ const num=parsePercentNumber(v); vv=(num==null)? v : fmtPct(num); } rows += `<tr><td>${k}</td><td><b>${vv==null? 'n/d' : vv}</b></td></tr>`; } if(!entries.length){ const ds=d.date? d.date.toISOString().slice(0,10) : 'n/d'; rows += `<tr><td>Área</td><td><b>${d.area}</b></td></tr>`; rows += `<tr><td>Data</td><td><b>${ds}</b></td></tr>`; rows += `<tr><td>Real</td><td><b>${fmtPct(d.real)}</b></td></tr>`; rows += `<tr><td>Planejado</td><td><b>${fmtPct(d.plan)}</b></td></tr>`; } return `<table>${rows}</table>`; })(); } else tooltip.style.opacity=0; }
    renderer.domElement.addEventListener('pointermove', onPointerMove);

    document.getElementById('btnFullscreen').addEventListener('click', async ()=>{ const el=document.getElementById('app'); if(!document.fullscreenElement){ try{ await el.requestFullscreen(); }catch{} } else { await document.exitFullscreen(); } });

    function resize(){ const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); } window.addEventListener('resize', resize); resize(); (function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); })();

    areaSelect.addEventListener('change', ()=>{ buildMarkers(dateSelect.value, areaSelect.value); focusCamera(); }); dateSelect.addEventListener('change', ()=>{ buildMarkers(dateSelect.value, areaSelect.value); });
    function focusCamera(){ const val=areaSelect.value; if(val!=='Todos' && areaToObject.has(val)){ const obj=areaToObject.get(val); controls.target.copy(obj.position); camera.position.lerp(new THREE.Vector3(obj.position.x+25, obj.position.y+12, obj.position.z+25), 0.2);} else { controls.target.set(0,4,0); camera.position.set(45,30,45);} }

    // Inicializa após carregar os dados
    buildSelectors(); buildMarkers('Todos','Todos');
  </script>
</body>
</html>
