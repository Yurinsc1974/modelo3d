<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dashboard 3D - Barragem (Dinâmico a partir do Excel)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b1020; color: #e6e8ef; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #app { position: fixed; inset: 0; display: grid; grid-template-columns: 1fr; grid-template-rows: 1fr; }
    #scene { grid-area: 1 / 1; }
    #ui { grid-area: 1 / 1; pointer-events: none; }
    .panel { position: absolute; top: 16px; left: 16px; background: rgba(10,15,35,.75); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 12px 14px; backdrop-filter: blur(6px); pointer-events: auto; display: flex; gap: 10px; align-items: center; }
    label { font-size: 12px; color: #c9d1e1; margin-right: 6px; }
    select { background: #11162b; border: 1px solid #2a355a; color: #e6e8ef; border-radius: 8px; padding: 6px 8px; }
    button { background: #2a355a; color: #fff; border: none; border-radius: 8px; padding: 8px 10px; cursor: pointer; }
    button:hover { background: #3b4980; }
    .legend { position: absolute; bottom: 16px; left: 16px; background: rgba(10,15,35,.75); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 8px 12px; pointer-events: auto; }
    .legend .bar { width: 200px; height: 10px; background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71); border-radius: 6px; margin-top: 6px; }
    .tooltip { position: absolute; padding: 6px 8px; background: rgba(0,0,0,.85); color: #fff; font-size: 12px; border-radius: 6px; transform: translate(-50%, -120%); pointer-events: none; opacity: 0; transition: opacity .15s; }
    .credit { position: absolute; right: 12px; bottom: 12px; color: #8b93a7; font-size: 12px; }

    /* Sidebar KPI */
    .sidebar { position: absolute; top: 80px; left: 16px; width: 280px; display: grid; gap: 12px; pointer-events: auto; }
    .kpi { background: linear-gradient(180deg, rgba(31,41,77,.85), rgba(20,27,52,.85)); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .kpi h4 { margin: 0 0 8px 0; font-size: 12px; font-weight: 600; letter-spacing: .6px; color: #aab4cf; text-transform: uppercase; }
    .kpi .val { font-size: 28px; font-weight: 700; }
    .kpi .sub { font-size: 12px; color: #aab4cf; }

    /* Error banner */
    .error { position: absolute; top: 16px; right: 16px; background: #3b1b1b; color: #ffd5d5; border: 1px solid #b14a4a; padding: 10px 12px; border-radius: 10px; pointer-events: auto; max-width: 420px; }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="scene"></canvas>
    <div id="ui">
      <div class="panel">
        <div>
          <label for="dateSelect">Data:</label>
          <select id="dateSelect"><option value="Todos">Todos</option></select>
        </div>
        <div>
          <label for="areaSelect">Área:</label>
          <select id="areaSelect"><option value="Todos">Todos</option></select>
        </div>
        <button id="btnFullscreen" title="Entrar em tela cheia">Tela cheia</button>
      </div>

      <div class="sidebar">
        <div class="kpi">
          <h4>Desempenho médio</h4>
          <div class="val" id="kpiRatio">n/d</div>
          <div class="sub">Média de Real / Planejado</div>
        </div>
        <div class="kpi">
          <h4>Real médio</h4>
          <div class="val" id="kpiReal">n/d</div>
          <div class="sub">% médio das áreas filtradas</div>
        </div>
        <div class="kpi">
          <h4>Planejado médio</h4>
          <div class="val" id="kpiPlan">n/d</div>
          <div class="sub">% médio das áreas filtradas</div>
        </div>
      </div>

      <div class="legend">
        <div>Cor do ponto = Desempenho (Real / Planejado)</div>
        <div class="bar"></div>
      </div>
      <div class="tooltip" id="tooltip"></div>
      <div class="credit">Fazendo 3D (Three.js)</div>
      <div class="error" id="error" style="display:none"></div>
    </div>
  </div>

  <script type="module">
    // ---------- Loader com fallback de CDNs ----------
    async function loadThree() {
      const threeURLs = [
        'https://esm.sh/three@0.160.0',
        'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
        'https://unpkg.com/three@0.160.0/build/three.module.js'
      ];
      const controlsURLs = [
        'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js',
        'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js?module',
        'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module'
      ];
      let lastErr;
      for (let i=0;i<threeURLs.length;i++){
        try { const THREE = await import(threeURLs[i]); const mod = await import(controlsURLs[i]); return { THREE, OrbitControls: mod.OrbitControls }; } catch(e){ lastErr=e; console.warn('CDN falhou', i+1, e); }
      }
      throw lastErr;
    }

    async function loadSheetJS() {
      const urls = [
        'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js',
        'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js'
      ];
      for (const u of urls) {
        try { await new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=u; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); if (window.XLSX) return window.XLSX; } catch(e){ console.warn('Falha SheetJS', u); }
      }
      throw new Error('Não foi possível carregar a biblioteca de Excel (SheetJS).');
    }

    const REQUIRED_AREAS = ['Dique','Maciço Principal','Miguel Congo','Regreide','Talude 08'];
    const PRESET_COORDS = {
      'Dique': [-20, 0, 0, 5],
      'Maciço Principal': [0, 0, 0, 8],
      'Miguel Congo': [20, 0, -10, 6],
      'Regreide': [-10, 0, 10, 4],
      'Talude 08': [10, 0, 12, 6],
    };

    const errBox = document.getElementById('error');
    function showError(msg){ errBox.style.display='block'; errBox.textContent = msg; }

    const { THREE, OrbitControls } = await loadThree();
    const XLSX = await loadSheetJS();

    // ---------- THREE: cena ----------
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
    camera.position.set(45, 30, 45);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.target.set(0, 4, 0);

    // Luzes e chão
    scene.add(new THREE.HemisphereLight(0xbfd7ff, 0x0b142a, 1.2));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(30,50,10); dir.castShadow = true; scene.add(dir);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x1a203a, roughness:0.95})); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);
    // Água
    const water = new THREE.Mesh(new THREE.PlaneGeometry(140,90), new THREE.MeshPhysicalMaterial({color:0x2c6fff, roughness:0.2, transmission:0.75, opacity:0.75, transparent:true}));
    water.rotation.x=-Math.PI/2; water.position.set(-10, 0.05, -10); scene.add(water);
    // Barragem
    const dam = new THREE.Group();
    const damBody = new THREE.Mesh(new THREE.BoxGeometry(60,12,20), new THREE.MeshStandardMaterial({color:0x6b6f7a})); damBody.position.set(10,6,0); damBody.rotation.z = THREE.MathUtils.degToRad(-10); damBody.castShadow=true; damBody.receiveShadow=true; dam.add(damBody);
    const crest = new THREE.Mesh(new THREE.BoxGeometry(60,2,6), new THREE.MeshStandardMaterial({color:0x9aa0a6})); crest.position.set(10,12.5,0); dam.add(crest); scene.add(dam);

    // ---------- UI e helpers ----------
    const areaSelect = document.getElementById('areaSelect');
    const dateSelect = document.getElementById('dateSelect');
    const tooltip = document.getElementById('tooltip');

    const kpiRatio = document.getElementById('kpiRatio');
    const kpiReal  = document.getElementById('kpiReal');
    const kpiPlan  = document.getElementById('kpiPlan');

    const markers = new THREE.Group(); scene.add(markers);
    const sphereGeo = new THREE.SphereGeometry(1.2, 32, 16);

    function colorFromRatio(r){ if (r==null||!isFinite(r)) return new THREE.Color(0x95a5a6); const t = (Math.max(0.7, Math.min(1.3, r)) - 0.7) / 0.6; const c = new THREE.Color(); c.setHSL(0.0 + t*0.33, 0.85, 0.5); return c; }

    function parseDate(v){ const d = new Date(v); return isNaN(d) ? null : d; }
    function fmt(v, digits=2){ return (v==null||!isFinite(v)) ? 'n/d' : (typeof v==='number' ? v.toFixed(digits) : String(v)); }

    // Carregar Excel
    let ROWS = [];
    async function loadExcel() {
      const res = await fetch('./Base.xlsx');
      if (!res.ok) throw new Error('Não foi possível baixar ./Base.xlsx');
      const buf = await res.arrayBuffer();
      const wb = XLSX.read(buf, {type:'array'});
      const wsName = wb.SheetNames[0];
      const ws = wb.Sheets[wsName];
      const json = XLSX.utils.sheet_to_json(ws, {defval:null});

      // Normalizar nomes de colunas (sem acentos e minúsculo)
      const norm = s => (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().trim();

      // Mapear colunas prováveis
      // área, data, real/real2, planejado/previsto
      const cols = Object.keys(json[0]||{});
      const normMap = { }; for (const c of cols) normMap[norm(c)] = c;
      const areaCol = normMap['area'] || Object.entries(normMap).find(([k])=>k.includes('area'))?.[1];
      const dateCol = normMap['data'] || Object.entries(normMap).find(([k])=>k.includes('data'))?.[1];
      const realCol = normMap['real'] || normMap['real2'] || Object.entries(normMap).find(([k])=>k.startsWith('real'))?.[1];
      const planCol = normMap['planejado'] || normMap['previsto'] || Object.entries(normMap).find(([k])=>k.includes('planejad')||k.includes('previst'))?.[1];

      if (!areaCol) throw new Error('Coluna "Área" não encontrada na planilha.');

      ROWS = json.map(r => ({
        area: String(r[areaCol]).trim(),
        date: dateCol ? r[dateCol] : null,
        real: realCol!=null ? (r[realCol]!=null? Number(r[realCol]) : null) : null,
        plan: planCol!=null ? (r[planCol]!=null? Number(r[planCol]) : null) : null,
      }));

      // Preencher ao menos as 5 áreas obrigatórias com placeholders (se não existirem em nenhuma linha)
      for (const a of REQUIRED_AREAS) {
        if (!ROWS.some(x => (x.area||'').toLowerCase() === a.toLowerCase())) ROWS.push({area:a, date:null, real:null, plan:null});
      }
    }

    function getUniqueDates(){ const ds = new Set(); for (const r of ROWS){ if (r.date){ const d = parseDate(r.date); if (d) ds.add(d.toISOString().slice(0,10)); } } return Array.from(ds).sort(); }
    function getUniqueAreas(){ const as = new Set(REQUIRED_AREAS); for (const r of ROWS) if (r.area) as.add(r.area); return Array.from(as); }

    function buildSelectors(){
      // Datas
      const dates = getUniqueDates();
      dateSelect.innerHTML = '<option value="Todos">Todos</option>' + dates.map(d=>`<option value="${d}">${d}</option>`).join('');
      // Áreas
      const areas = getUniqueAreas();
      areaSelect.innerHTML = '<option value="Todos">Todos</option>' + areas.map(a=>`<option value="${a}">${a}</option>`).join('');
    }

    function filterRows(selDate, selArea){
      return ROWS.filter(r=>{
        const okDate = (selDate==='Todos') || (!!r.date && (new Date(r.date)).toISOString().slice(0,10)===selDate);
        const okArea = (selArea==='Todos') || (r.area===selArea);
        return okDate && okArea;
      });
    }

    function aggregateForDate(selDate){
      // Para exibir 1 ponto por área: selecionar, para cada área, a linha mais recente até a data sel/qualquer
      const byArea = new Map();
      for (const r of ROWS){
        const rDate = r.date ? parseDate(r.date) : null;
        if (selDate!=='Todos' && rDate && rDate.toISOString().slice(0,10)!==selDate) continue;
        const key = r.area || 'Área';
        const prev = byArea.get(key);
        if (!prev) byArea.set(key, r);
        else {
          const pd = prev.date ? parseDate(prev.date) : null; const rd = rDate;
          if (!pd && rd) byArea.set(key, r);
          else if (pd && rd && rd>pd) byArea.set(key, r);
        }
      }
      // garantir as 5 áreas
      for (const a of REQUIRED_AREAS){ if (!byArea.has(a)) byArea.set(a, {area:a, date:null, real:null, plan:null}); }
      return Array.from(byArea.values());
    }

    function updateKPI(rows){
      const vals = rows.map(r=>({real:r.real, plan:r.plan, ratio: (r.real!=null && r.plan)? (r.plan!==0? r.real/r.plan : null) : null}));
      const mean = (arr)=>{ const v = arr.filter(x=>x!=null && isFinite(x)); return v.length? (v.reduce((a,b)=>a+b,0)/v.length) : null; };
      kpiRatio.textContent = fmt(mean(vals.map(v=>v.ratio)));
      kpiReal.textContent  = fmt(mean(vals.map(v=>v.real)));
      kpiPlan.textContent  = fmt(mean(vals.map(v=>v.plan)));
    }

    const areaToObject = new Map();

    function buildMarkers(selDate='Todos', selArea='Todos'){
      while (markers.children.length) markers.remove(markers.children[0]);
      areaToObject.clear();

      const rows = aggregateForDate(selDate).filter(r=> selArea==='Todos' ? true : r.area===selArea);

      for (const d of rows){
        const coords = PRESET_COORDS[d.area] || [0,0,0,5];
        const [x,y,z,h] = coords;
        const ratio = (d.real!=null && d.plan)? (d.plan!==0? d.real/d.plan:null) : null;
        const mat = new THREE.MeshStandardMaterial({color: colorFromRatio(ratio), roughness:0.4});
        const mesh = new THREE.Mesh(sphereGeo, mat); mesh.position.set(x, h, z); mesh.castShadow=true; mesh.userData={...d, ratio, height:h};

        const ped = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,h,12), new THREE.MeshStandardMaterial({color:0x3a466f, roughness:0.9})); ped.position.set(x,h/2,z); ped.castShadow=true; ped.receiveShadow=true;
        markers.add(ped); markers.add(mesh);
        areaToObject.set(d.area, mesh);
      }

      updateKPI(rows);
    }

    // Hover tooltip
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function onPointerMove(e){
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX-rect.left)/rect.width)*2 - 1;
      mouse.y = -((e.clientY-rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(markers.children, true).filter(i=> i.object.geometry===sphereGeo);
      if (intersects.length){
        const d = intersects[0].object.userData;
        tooltip.style.left = e.clientX + 'px'; tooltip.style.top = e.clientY + 'px'; tooltip.style.opacity = 1;
        const dstr = d.date ? new Date(d.date).toISOString().slice(0,10) : 'n/d';
        tooltip.innerHTML = `<b>${d.area}</b><br/>Data: ${dstr}<br/>Real: ${fmt(d.real)}<br/>Planejado: ${fmt(d.plan)}<br/>Razão: ${d.ratio? d.ratio.toFixed(2):'n/d'}`;
      } else tooltip.style.opacity = 0;
    }

    renderer.domElement.addEventListener('pointermove', onPointerMove);

    // Fullscreen
    document.getElementById('btnFullscreen').addEventListener('click', async ()=>{
      const el = document.getElementById('app'); if (!document.fullscreenElement){ try { await el.requestFullscreen(); } catch {} } else { await document.exitFullscreen(); }
    });

    // Resize & animate
    function resize(){ const w=window.innerWidth, h=window.innerHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }
    window.addEventListener('resize', resize); resize();
    (function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); })();

    // Selectors
    areaSelect.addEventListener('change', ()=>{ buildMarkers(dateSelect.value, areaSelect.value); focusCamera(); });
    dateSelect.addEventListener('change', ()=>{ buildMarkers(dateSelect.value, areaSelect.value); });

    function focusCamera(){ const val = areaSelect.value; if (val!=='Todos' && areaToObject.has(val)){ const obj = areaToObject.get(val); controls.target.copy(obj.position); camera.position.lerp(new THREE.Vector3(obj.position.x + 25, obj.position.y + 12, obj.position.z + 25), 0.2);} else { controls.target.set(0,4,0); camera.position.set(45,30,45); } }

    // ---------- Boot ----------
    try {
      await loadExcel();
      buildSelectors();
      buildMarkers('Todos','Todos');
    } catch(e){ console.error(e); showError(e.message || String(e)); }
  </script>
</body>
</html>
</body>
</html>
